---
title: Javascript - 스코프(접근 가능한 유효 범위)
categories:
- Javascript
feature_text: |
  The History of the Alembic tool
---



#### <전역 스코프(Global Scope)>
>최외곽의 영역에 해당하며 이 안에 정의된 변수나 함수는 어디에서든지 접근할 수 있다.
```javascript
var a = 1;
let b = 2;
function aa(){
  var c = 3;
  let d = 4;
}
for( b; b<5; b+=1;){
  var e = 5;
  let f = 6;
}
console.log(b);
```

ex) 전역스코프 : a, b, aa, e


#### &lt;지역 스코프(Local Scope)&gt;
>함수 또는 블록을 기준으로 생긴 영역에 해당하며 전역 스코프의 내부에 있는 영역으로 이 안에 정의된 변수나 함수를 이 지역 스코프보다 외부(스코프)에서 접근할 수 없다.

ex) 지역스코프<br>
1\. aa(함수)스코프 : c, d<br>
2\. for(블록)스코프 : f

---

#### &lt;함수 스코프(Function Scope)&gt;
>-함수를 기준으로 {  } 내부를 의미한다.<br>
-여기서 정의된 변수나 함수는 이 스코프나 더 안에 있는 내부 스코프에서만 접근할 수 있다. (동등한 레벨의 다른 스코프나 외부 스코프에서는 접근 불가)

ex) aa(함수)스코프 : c, d

#### &lt;블록 스코프(Block Scope)&gt;
>-블록을 기준으로 {  } 내부를 의미한다.<br>
-여기서 정의된 변수나 함수는 이 스코프나 더 안에 있는 내부 스코프에서만 접근할 수 있다. (동등한 레벨의 다른 스코프나 외부 스코프에서는 접근 불가)

ex) for(블록)스코프 : f 

---
#### &lt;정적 스코프&gt;
>**함수가 선언될 시**의 환경(중첩 구조)을 스코프 영역(Lexical Scope)으로 형성한다.

```javascript
let a = 1;
function aa () {
  let b = 2;
  console.log(a); // 1 출력.
  function bb () {
    console.log(a); // 1 출력.
    console.log(b); // 2 출력.
  }
  bb();
}
aa();
```

ex) bb(함수)스코프에 a 와 b 변수가 존재하지 않지만 바깥으로 해당 변수가 존재하는지 찾을 때 까지 뻗어나간다.
aa(함수)스코프에서도 a 가 존재하지 않지만 전역으로 찾아 나가서 값을 가져온다.

bb 함수의 렉시컬 스코프는 전역-aa-bb 로 참조할 수 있게 묶어서 형성된다.
aa 함수의 렉시컬 스코프는 전역-aa


#### &lt;동적 스코프&gt;
>**함수가 호출될 시**의 환경(중첩 구조)을 기준으로 스코프 영역을 형성한다.

```javascript
let a = 1;

function aa(){
  let b = 2;
  bb();
}

function bb(){
  let c = 3;
  console.log(b);
}

aa();
```

ex) 자바스크립트는 정적스코프언어 라서 위 코드를 실행하면 error가 난다.
함수 선언 시의 환경을 스코프 영역으로 가지니 aa(함수)스코프는 같은 레벨인 bb(함수)스코프를 참조할 수 없기 때문이다.
하지만 동적스코프라고 가정한다면 위 코드는 error가 나지 않고 bb함수가 호출될 때 aa함수 내부이므로 aa함수를 참조할 수 있게 되어 2를 출력하게 된다.

---

#### &lt;스코프 체인(Scope Chain)&gt;
>현재 스코프(영역)에서 찾고 있는 변수나 함수가 없으면 현재 영역 바로 바깥의 스코프로 해당 정보를 찾을 때 까지 나아가는 것. ( 지금보다 외부이면서 가장 가까운 스코프를 방문해 찾는다. )
이 스코프 체인으로 렉시컬 스코프가 형성된다.

ex) 위의 정적스코프 예제에서 bb(함수)스코프가 aa(함수)스코프 와 전역스코프 를 참조할 수 있게 연결된 것.
aa(함수)스코프가 전역스코프 를 참조할 수 있게 된 것도 마찬가지.

---

#### < 호이스팅 과 스코프 >

```javascript
bb(); // 같은 스코프니까 선언 전에 호출 가능.
var g = 9;
function bb(){
  let  f = 8;
  console.log(f);
    }
```
>위와 같이 같은 스코프라면 선언 전에 함수를 호출하여 사용할 수 있다. 하지만 다음과 같은 경우에서는 선언 전에 함수를 호출할 수 없게 된다.

---

>var 와 function은 함수레벨 스코프라서 호이스팅에 의해 블록스코프를 탈출하게 되는데
블록 밖에서는 undefined로 조회는 가능하지만 사용할 수 없는 변수와 함수가 된다.


```javascript

console.log(bb); //undefined. bb 함수는 호이스팅이 일어나서 undefined로 출력은 가능.
bb(); // error. bb 함수 호출은 불가능하다.
for(let d = 0; d<2; d+=1){
  function bb(){
    let  f = 8;
    console.log(f);
  }
  bb(); // 여기는 같은 스코프니까 호출 가능.
}
```
>var 인 경우 실제 메모리 값 부여(할당)는 자신의 원래 자리에서 일어나는데 for문이나 if문 같은 블록스코프 내부는 블록 스코프로 닫혀 버리니 외부에서 접근할 수 없게 되어버린다.

>function 인 경우 호출 되어야 실제 메모리 값 부여가 되는데 for문이나 if문 같은 블록스코프 내부가 아닌 밖에서 호출등이 불가능 해지니 접근할 수 없게 된다.

>if문은 새 블록스코프 안에, for문 같은 경우 새 블록스코프가 반복 횟수만큼 생기며 이 안에 var로 선언한 변수나 function이 생기게 된다.

+ **그러므로 var 선언 최대한 지양하고 const 를 쓰려고 하되, 재할당이 필요한 변수의 경우 let 을 사용한다.
함수 같은 경우도 해당 스코프 안에서만 사용할 건지 다른 곳에서도 사용할 것인지를 잘 판단해서 선언하는 위치를 잘 잡아야 한다.**